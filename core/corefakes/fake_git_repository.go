// Code generated by counterfeiter. DO NOT EDIT.
package corefakes

import (
	"io/fs"
	"sync"

	"github.com/ccremer/greposync/core"
)

type FakeGitRepository struct {
	CheckoutStub        func() error
	checkoutMutex       sync.RWMutex
	checkoutArgsForCall []struct {
	}
	checkoutReturns struct {
		result1 error
	}
	checkoutReturnsOnCall map[int]struct {
		result1 error
	}
	CloneStub        func() error
	cloneMutex       sync.RWMutex
	cloneArgsForCall []struct {
	}
	cloneReturns struct {
		result1 error
	}
	cloneReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteFileStub        func(string) error
	deleteFileMutex       sync.RWMutex
	deleteFileArgsForCall []struct {
		arg1 string
	}
	deleteFileReturns struct {
		result1 error
	}
	deleteFileReturnsOnCall map[int]struct {
		result1 error
	}
	EnsureFileStub        func(string, string, fs.FileMode) error
	ensureFileMutex       sync.RWMutex
	ensureFileArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 fs.FileMode
	}
	ensureFileReturns struct {
		result1 error
	}
	ensureFileReturnsOnCall map[int]struct {
		result1 error
	}
	EnsurePullRequestStub        func(core.PullRequest) error
	ensurePullRequestMutex       sync.RWMutex
	ensurePullRequestArgsForCall []struct {
		arg1 core.PullRequest
	}
	ensurePullRequestReturns struct {
		result1 error
	}
	ensurePullRequestReturnsOnCall map[int]struct {
		result1 error
	}
	FetchStub        func() error
	fetchMutex       sync.RWMutex
	fetchArgsForCall []struct {
	}
	fetchReturns struct {
		result1 error
	}
	fetchReturnsOnCall map[int]struct {
		result1 error
	}
	FetchPullRequestStub        func() (core.PullRequest, error)
	fetchPullRequestMutex       sync.RWMutex
	fetchPullRequestArgsForCall []struct {
	}
	fetchPullRequestReturns struct {
		result1 core.PullRequest
		result2 error
	}
	fetchPullRequestReturnsOnCall map[int]struct {
		result1 core.PullRequest
		result2 error
	}
	GetConfigStub        func() core.GitRepositoryProperties
	getConfigMutex       sync.RWMutex
	getConfigArgsForCall []struct {
	}
	getConfigReturns struct {
		result1 core.GitRepositoryProperties
	}
	getConfigReturnsOnCall map[int]struct {
		result1 core.GitRepositoryProperties
	}
	GetLabelsStub        func() []core.Label
	getLabelsMutex       sync.RWMutex
	getLabelsArgsForCall []struct {
	}
	getLabelsReturns struct {
		result1 []core.Label
	}
	getLabelsReturnsOnCall map[int]struct {
		result1 []core.Label
	}
	NewPullRequestStub        func() core.PullRequest
	newPullRequestMutex       sync.RWMutex
	newPullRequestArgsForCall []struct {
	}
	newPullRequestReturns struct {
		result1 core.PullRequest
	}
	newPullRequestReturnsOnCall map[int]struct {
		result1 core.PullRequest
	}
	PullStub        func() error
	pullMutex       sync.RWMutex
	pullArgsForCall []struct {
	}
	pullReturns struct {
		result1 error
	}
	pullReturnsOnCall map[int]struct {
		result1 error
	}
	ResetStub        func() error
	resetMutex       sync.RWMutex
	resetArgsForCall []struct {
	}
	resetReturns struct {
		result1 error
	}
	resetReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitRepository) Checkout() error {
	fake.checkoutMutex.Lock()
	ret, specificReturn := fake.checkoutReturnsOnCall[len(fake.checkoutArgsForCall)]
	fake.checkoutArgsForCall = append(fake.checkoutArgsForCall, struct {
	}{})
	stub := fake.CheckoutStub
	fakeReturns := fake.checkoutReturns
	fake.recordInvocation("Checkout", []interface{}{})
	fake.checkoutMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) CheckoutCallCount() int {
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	return len(fake.checkoutArgsForCall)
}

func (fake *FakeGitRepository) CheckoutCalls(stub func() error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = stub
}

func (fake *FakeGitRepository) CheckoutReturns(result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	fake.checkoutReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) CheckoutReturnsOnCall(i int, result1 error) {
	fake.checkoutMutex.Lock()
	defer fake.checkoutMutex.Unlock()
	fake.CheckoutStub = nil
	if fake.checkoutReturnsOnCall == nil {
		fake.checkoutReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.checkoutReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) Clone() error {
	fake.cloneMutex.Lock()
	ret, specificReturn := fake.cloneReturnsOnCall[len(fake.cloneArgsForCall)]
	fake.cloneArgsForCall = append(fake.cloneArgsForCall, struct {
	}{})
	stub := fake.CloneStub
	fakeReturns := fake.cloneReturns
	fake.recordInvocation("Clone", []interface{}{})
	fake.cloneMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) CloneCallCount() int {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	return len(fake.cloneArgsForCall)
}

func (fake *FakeGitRepository) CloneCalls(stub func() error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = stub
}

func (fake *FakeGitRepository) CloneReturns(result1 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	fake.cloneReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) CloneReturnsOnCall(i int, result1 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	if fake.cloneReturnsOnCall == nil {
		fake.cloneReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cloneReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) DeleteFile(arg1 string) error {
	fake.deleteFileMutex.Lock()
	ret, specificReturn := fake.deleteFileReturnsOnCall[len(fake.deleteFileArgsForCall)]
	fake.deleteFileArgsForCall = append(fake.deleteFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteFileStub
	fakeReturns := fake.deleteFileReturns
	fake.recordInvocation("DeleteFile", []interface{}{arg1})
	fake.deleteFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) DeleteFileCallCount() int {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	return len(fake.deleteFileArgsForCall)
}

func (fake *FakeGitRepository) DeleteFileCalls(stub func(string) error) {
	fake.deleteFileMutex.Lock()
	defer fake.deleteFileMutex.Unlock()
	fake.DeleteFileStub = stub
}

func (fake *FakeGitRepository) DeleteFileArgsForCall(i int) string {
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	argsForCall := fake.deleteFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitRepository) DeleteFileReturns(result1 error) {
	fake.deleteFileMutex.Lock()
	defer fake.deleteFileMutex.Unlock()
	fake.DeleteFileStub = nil
	fake.deleteFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) DeleteFileReturnsOnCall(i int, result1 error) {
	fake.deleteFileMutex.Lock()
	defer fake.deleteFileMutex.Unlock()
	fake.DeleteFileStub = nil
	if fake.deleteFileReturnsOnCall == nil {
		fake.deleteFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) EnsureFile(arg1 string, arg2 string, arg3 fs.FileMode) error {
	fake.ensureFileMutex.Lock()
	ret, specificReturn := fake.ensureFileReturnsOnCall[len(fake.ensureFileArgsForCall)]
	fake.ensureFileArgsForCall = append(fake.ensureFileArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 fs.FileMode
	}{arg1, arg2, arg3})
	stub := fake.EnsureFileStub
	fakeReturns := fake.ensureFileReturns
	fake.recordInvocation("EnsureFile", []interface{}{arg1, arg2, arg3})
	fake.ensureFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) EnsureFileCallCount() int {
	fake.ensureFileMutex.RLock()
	defer fake.ensureFileMutex.RUnlock()
	return len(fake.ensureFileArgsForCall)
}

func (fake *FakeGitRepository) EnsureFileCalls(stub func(string, string, fs.FileMode) error) {
	fake.ensureFileMutex.Lock()
	defer fake.ensureFileMutex.Unlock()
	fake.EnsureFileStub = stub
}

func (fake *FakeGitRepository) EnsureFileArgsForCall(i int) (string, string, fs.FileMode) {
	fake.ensureFileMutex.RLock()
	defer fake.ensureFileMutex.RUnlock()
	argsForCall := fake.ensureFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeGitRepository) EnsureFileReturns(result1 error) {
	fake.ensureFileMutex.Lock()
	defer fake.ensureFileMutex.Unlock()
	fake.EnsureFileStub = nil
	fake.ensureFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) EnsureFileReturnsOnCall(i int, result1 error) {
	fake.ensureFileMutex.Lock()
	defer fake.ensureFileMutex.Unlock()
	fake.EnsureFileStub = nil
	if fake.ensureFileReturnsOnCall == nil {
		fake.ensureFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensureFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) EnsurePullRequest(arg1 core.PullRequest) error {
	fake.ensurePullRequestMutex.Lock()
	ret, specificReturn := fake.ensurePullRequestReturnsOnCall[len(fake.ensurePullRequestArgsForCall)]
	fake.ensurePullRequestArgsForCall = append(fake.ensurePullRequestArgsForCall, struct {
		arg1 core.PullRequest
	}{arg1})
	stub := fake.EnsurePullRequestStub
	fakeReturns := fake.ensurePullRequestReturns
	fake.recordInvocation("EnsurePullRequest", []interface{}{arg1})
	fake.ensurePullRequestMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) EnsurePullRequestCallCount() int {
	fake.ensurePullRequestMutex.RLock()
	defer fake.ensurePullRequestMutex.RUnlock()
	return len(fake.ensurePullRequestArgsForCall)
}

func (fake *FakeGitRepository) EnsurePullRequestCalls(stub func(core.PullRequest) error) {
	fake.ensurePullRequestMutex.Lock()
	defer fake.ensurePullRequestMutex.Unlock()
	fake.EnsurePullRequestStub = stub
}

func (fake *FakeGitRepository) EnsurePullRequestArgsForCall(i int) core.PullRequest {
	fake.ensurePullRequestMutex.RLock()
	defer fake.ensurePullRequestMutex.RUnlock()
	argsForCall := fake.ensurePullRequestArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitRepository) EnsurePullRequestReturns(result1 error) {
	fake.ensurePullRequestMutex.Lock()
	defer fake.ensurePullRequestMutex.Unlock()
	fake.EnsurePullRequestStub = nil
	fake.ensurePullRequestReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) EnsurePullRequestReturnsOnCall(i int, result1 error) {
	fake.ensurePullRequestMutex.Lock()
	defer fake.ensurePullRequestMutex.Unlock()
	fake.EnsurePullRequestStub = nil
	if fake.ensurePullRequestReturnsOnCall == nil {
		fake.ensurePullRequestReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ensurePullRequestReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) Fetch() error {
	fake.fetchMutex.Lock()
	ret, specificReturn := fake.fetchReturnsOnCall[len(fake.fetchArgsForCall)]
	fake.fetchArgsForCall = append(fake.fetchArgsForCall, struct {
	}{})
	stub := fake.FetchStub
	fakeReturns := fake.fetchReturns
	fake.recordInvocation("Fetch", []interface{}{})
	fake.fetchMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) FetchCallCount() int {
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	return len(fake.fetchArgsForCall)
}

func (fake *FakeGitRepository) FetchCalls(stub func() error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = stub
}

func (fake *FakeGitRepository) FetchReturns(result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	fake.fetchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) FetchReturnsOnCall(i int, result1 error) {
	fake.fetchMutex.Lock()
	defer fake.fetchMutex.Unlock()
	fake.FetchStub = nil
	if fake.fetchReturnsOnCall == nil {
		fake.fetchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fetchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) FetchPullRequest() (core.PullRequest, error) {
	fake.fetchPullRequestMutex.Lock()
	ret, specificReturn := fake.fetchPullRequestReturnsOnCall[len(fake.fetchPullRequestArgsForCall)]
	fake.fetchPullRequestArgsForCall = append(fake.fetchPullRequestArgsForCall, struct {
	}{})
	stub := fake.FetchPullRequestStub
	fakeReturns := fake.fetchPullRequestReturns
	fake.recordInvocation("FetchPullRequest", []interface{}{})
	fake.fetchPullRequestMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitRepository) FetchPullRequestCallCount() int {
	fake.fetchPullRequestMutex.RLock()
	defer fake.fetchPullRequestMutex.RUnlock()
	return len(fake.fetchPullRequestArgsForCall)
}

func (fake *FakeGitRepository) FetchPullRequestCalls(stub func() (core.PullRequest, error)) {
	fake.fetchPullRequestMutex.Lock()
	defer fake.fetchPullRequestMutex.Unlock()
	fake.FetchPullRequestStub = stub
}

func (fake *FakeGitRepository) FetchPullRequestReturns(result1 core.PullRequest, result2 error) {
	fake.fetchPullRequestMutex.Lock()
	defer fake.fetchPullRequestMutex.Unlock()
	fake.FetchPullRequestStub = nil
	fake.fetchPullRequestReturns = struct {
		result1 core.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeGitRepository) FetchPullRequestReturnsOnCall(i int, result1 core.PullRequest, result2 error) {
	fake.fetchPullRequestMutex.Lock()
	defer fake.fetchPullRequestMutex.Unlock()
	fake.FetchPullRequestStub = nil
	if fake.fetchPullRequestReturnsOnCall == nil {
		fake.fetchPullRequestReturnsOnCall = make(map[int]struct {
			result1 core.PullRequest
			result2 error
		})
	}
	fake.fetchPullRequestReturnsOnCall[i] = struct {
		result1 core.PullRequest
		result2 error
	}{result1, result2}
}

func (fake *FakeGitRepository) GetConfig() core.GitRepositoryProperties {
	fake.getConfigMutex.Lock()
	ret, specificReturn := fake.getConfigReturnsOnCall[len(fake.getConfigArgsForCall)]
	fake.getConfigArgsForCall = append(fake.getConfigArgsForCall, struct {
	}{})
	stub := fake.GetConfigStub
	fakeReturns := fake.getConfigReturns
	fake.recordInvocation("GetConfig", []interface{}{})
	fake.getConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) GetConfigCallCount() int {
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	return len(fake.getConfigArgsForCall)
}

func (fake *FakeGitRepository) GetConfigCalls(stub func() core.GitRepositoryProperties) {
	fake.getConfigMutex.Lock()
	defer fake.getConfigMutex.Unlock()
	fake.GetConfigStub = stub
}

func (fake *FakeGitRepository) GetConfigReturns(result1 core.GitRepositoryProperties) {
	fake.getConfigMutex.Lock()
	defer fake.getConfigMutex.Unlock()
	fake.GetConfigStub = nil
	fake.getConfigReturns = struct {
		result1 core.GitRepositoryProperties
	}{result1}
}

func (fake *FakeGitRepository) GetConfigReturnsOnCall(i int, result1 core.GitRepositoryProperties) {
	fake.getConfigMutex.Lock()
	defer fake.getConfigMutex.Unlock()
	fake.GetConfigStub = nil
	if fake.getConfigReturnsOnCall == nil {
		fake.getConfigReturnsOnCall = make(map[int]struct {
			result1 core.GitRepositoryProperties
		})
	}
	fake.getConfigReturnsOnCall[i] = struct {
		result1 core.GitRepositoryProperties
	}{result1}
}

func (fake *FakeGitRepository) GetLabels() []core.Label {
	fake.getLabelsMutex.Lock()
	ret, specificReturn := fake.getLabelsReturnsOnCall[len(fake.getLabelsArgsForCall)]
	fake.getLabelsArgsForCall = append(fake.getLabelsArgsForCall, struct {
	}{})
	stub := fake.GetLabelsStub
	fakeReturns := fake.getLabelsReturns
	fake.recordInvocation("GetLabels", []interface{}{})
	fake.getLabelsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) GetLabelsCallCount() int {
	fake.getLabelsMutex.RLock()
	defer fake.getLabelsMutex.RUnlock()
	return len(fake.getLabelsArgsForCall)
}

func (fake *FakeGitRepository) GetLabelsCalls(stub func() []core.Label) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = stub
}

func (fake *FakeGitRepository) GetLabelsReturns(result1 []core.Label) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = nil
	fake.getLabelsReturns = struct {
		result1 []core.Label
	}{result1}
}

func (fake *FakeGitRepository) GetLabelsReturnsOnCall(i int, result1 []core.Label) {
	fake.getLabelsMutex.Lock()
	defer fake.getLabelsMutex.Unlock()
	fake.GetLabelsStub = nil
	if fake.getLabelsReturnsOnCall == nil {
		fake.getLabelsReturnsOnCall = make(map[int]struct {
			result1 []core.Label
		})
	}
	fake.getLabelsReturnsOnCall[i] = struct {
		result1 []core.Label
	}{result1}
}

func (fake *FakeGitRepository) NewPullRequest() core.PullRequest {
	fake.newPullRequestMutex.Lock()
	ret, specificReturn := fake.newPullRequestReturnsOnCall[len(fake.newPullRequestArgsForCall)]
	fake.newPullRequestArgsForCall = append(fake.newPullRequestArgsForCall, struct {
	}{})
	stub := fake.NewPullRequestStub
	fakeReturns := fake.newPullRequestReturns
	fake.recordInvocation("NewPullRequest", []interface{}{})
	fake.newPullRequestMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) NewPullRequestCallCount() int {
	fake.newPullRequestMutex.RLock()
	defer fake.newPullRequestMutex.RUnlock()
	return len(fake.newPullRequestArgsForCall)
}

func (fake *FakeGitRepository) NewPullRequestCalls(stub func() core.PullRequest) {
	fake.newPullRequestMutex.Lock()
	defer fake.newPullRequestMutex.Unlock()
	fake.NewPullRequestStub = stub
}

func (fake *FakeGitRepository) NewPullRequestReturns(result1 core.PullRequest) {
	fake.newPullRequestMutex.Lock()
	defer fake.newPullRequestMutex.Unlock()
	fake.NewPullRequestStub = nil
	fake.newPullRequestReturns = struct {
		result1 core.PullRequest
	}{result1}
}

func (fake *FakeGitRepository) NewPullRequestReturnsOnCall(i int, result1 core.PullRequest) {
	fake.newPullRequestMutex.Lock()
	defer fake.newPullRequestMutex.Unlock()
	fake.NewPullRequestStub = nil
	if fake.newPullRequestReturnsOnCall == nil {
		fake.newPullRequestReturnsOnCall = make(map[int]struct {
			result1 core.PullRequest
		})
	}
	fake.newPullRequestReturnsOnCall[i] = struct {
		result1 core.PullRequest
	}{result1}
}

func (fake *FakeGitRepository) Pull() error {
	fake.pullMutex.Lock()
	ret, specificReturn := fake.pullReturnsOnCall[len(fake.pullArgsForCall)]
	fake.pullArgsForCall = append(fake.pullArgsForCall, struct {
	}{})
	stub := fake.PullStub
	fakeReturns := fake.pullReturns
	fake.recordInvocation("Pull", []interface{}{})
	fake.pullMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) PullCallCount() int {
	fake.pullMutex.RLock()
	defer fake.pullMutex.RUnlock()
	return len(fake.pullArgsForCall)
}

func (fake *FakeGitRepository) PullCalls(stub func() error) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = stub
}

func (fake *FakeGitRepository) PullReturns(result1 error) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = nil
	fake.pullReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) PullReturnsOnCall(i int, result1 error) {
	fake.pullMutex.Lock()
	defer fake.pullMutex.Unlock()
	fake.PullStub = nil
	if fake.pullReturnsOnCall == nil {
		fake.pullReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pullReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) Reset() error {
	fake.resetMutex.Lock()
	ret, specificReturn := fake.resetReturnsOnCall[len(fake.resetArgsForCall)]
	fake.resetArgsForCall = append(fake.resetArgsForCall, struct {
	}{})
	stub := fake.ResetStub
	fakeReturns := fake.resetReturns
	fake.recordInvocation("Reset", []interface{}{})
	fake.resetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeGitRepository) ResetCallCount() int {
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	return len(fake.resetArgsForCall)
}

func (fake *FakeGitRepository) ResetCalls(stub func() error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = stub
}

func (fake *FakeGitRepository) ResetReturns(result1 error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = nil
	fake.resetReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) ResetReturnsOnCall(i int, result1 error) {
	fake.resetMutex.Lock()
	defer fake.resetMutex.Unlock()
	fake.ResetStub = nil
	if fake.resetReturnsOnCall == nil {
		fake.resetReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.resetReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkoutMutex.RLock()
	defer fake.checkoutMutex.RUnlock()
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	fake.deleteFileMutex.RLock()
	defer fake.deleteFileMutex.RUnlock()
	fake.ensureFileMutex.RLock()
	defer fake.ensureFileMutex.RUnlock()
	fake.ensurePullRequestMutex.RLock()
	defer fake.ensurePullRequestMutex.RUnlock()
	fake.fetchMutex.RLock()
	defer fake.fetchMutex.RUnlock()
	fake.fetchPullRequestMutex.RLock()
	defer fake.fetchPullRequestMutex.RUnlock()
	fake.getConfigMutex.RLock()
	defer fake.getConfigMutex.RUnlock()
	fake.getLabelsMutex.RLock()
	defer fake.getLabelsMutex.RUnlock()
	fake.newPullRequestMutex.RLock()
	defer fake.newPullRequestMutex.RUnlock()
	fake.pullMutex.RLock()
	defer fake.pullMutex.RUnlock()
	fake.resetMutex.RLock()
	defer fake.resetMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ core.GitRepository = new(FakeGitRepository)
